# Grafički korisnički interfejs (GUI)

- suštinska razlika GUI app i komandno-linijskih je što main fja postaje nebitna jer ona sada
starta kod za početak ostatka programa

## Programiranje vođeno događajima

- programiranje vođeno događajima (event-driven programming) je programska paradigma kod koje se 
programi ne izvršavaju sekvencijalno, nego je izvršenje određenih procedura (fja) uzrokovano nekim događajima izvana.
- osnovni element GUI programa je petlja događaja (event loop) koja je besk. petlja u kojoj se provjerava
da li je došlo do događaja. 
- Ako se desi događaj, poziva se odgovarajuća fja - rukovodilac događaja (event handler)
- sa Thread.sleep(1000) procesor odmara 0.1s i daje drugim programima da se izvršavaju
inače radi konstantno

## Biblioteke za grafičko okruženje

- možemo ih pratiti po generacijama:
1. Prva generacija (80 i 90te) - GUI toolkits
2. Druga generacija (00te) - GUI frameworks
3. Treća generacija (10te) - deklarativni interfejs

## Dizajneri korisničkog interfejsa

- program u kojem se može nacrtati kako želite da izgleda korisnički interfejs vašeg programa,
a on će izgenerisati potrebni kod.
- uz biblioteke 1. i 2. gen. generiše se programski kod koji je vrlo težak za ručnu promjenu,
dok kod 3. gen. generiše se XML koji je lakši sa održavanje i manja je vjerovatnoća grešaka

## Java UI

- prvobitni cilj Jave - olakšan razvoj GUI apps
- awt - biblioteka je zastarjela, 1.gen bibl.
- swing - uključena od Java 1.2, awt 2.0, dosta bolje
- swt - dio Eclipsea, swing 2.0, ali sporija
- javafx - uključena od Java 8 u SDK, 3. gen., najbolja zasad
- pošto nije više javafx uključeno, mora se install u pom.xml sa javafx-maven-plugin

## JavaFX Hello World - osnova svakog windowa

```java
public class Main extends Application {
    @Override
    public void start(Stage stage) throws Exception{
        Parent root = FXMLLoader.load(getClass().getResource("sample.fxml"));
        stage.setTitle("Hello, World!");
        stage.setScene(new Scene(root, 300, 275));
        stage.show();
    }
    public static void main(String[] args) { launch(args); } // ovo nije ni potrebno ako se pokrece kroz CMD
}
```
## Struktura JavaFX app

(slika sa prezentacije)

## Osnovni pojmovi JavaFX biblioteke

- primarna klasa u kojoj se kreiraju svi vizuelni elementi, prozor : Stage
- sadržaj prozora : Scene

## Primjer - kreiranje UI iz koda + layout panes

```java
public void start(Stage primaryStage) throws Exception {
   StackPane pane = new StackPane();
   pane.getChildren().add(new Button("OK"));
   Scene scene = new Scene(pane, 200, 50);
   primaryStage.setTitle("Button in a pane"); // Set the stage title
   primaryStage.setScene(scene); // Place the scene in the stage
   primaryStage.show(); // Display the stage
}
```
- dostupni layouts su: HBox, VBox, FlowPane, TilePane, StackPane, GridPane, BorderPane, AnchorPane

## Deklarativni UI

- JavaFX je savremeni deklarativni framework
- FXML je jezik za opis UI zasnovan na XMLu

## FXML / Scene Builder

- spriječiti resizeanje prozora možemo sa stage.setResizable(false);

## IntelliJ JavaFX Configuracija

- ako piše error: JavaFX runtime components are missing... popravljamo sa dodavanjem VM opcija
- --module-path $JAVA_FX_HOME/lib --add-modules javafx.fxml,javafx.controls

## Resizing GridPane

- Uočavamo da se kada mijenjamo veličinu prozora, naš GridPane se ne resizuje kako treba. Ovo postižemo atributima polja ColumnConstraints i RowConstraints u FXML-u:
- Ako želimo da se širina i visina polja prilagodi širini i visini prozora, u ColumnConstraints dodajemo hgrow="ALWAYS" (slično u RowConstraints dodajemo vgrow)
- Možemo zadati širinu i visinu polja u procentima: percentWidth="33.3" ili percentHeight="20"
- Moguće je zadati minimalnu širinu/visinu ispod koje se dalje ne može resizovati (minWidth…)
- Da bismo postigli da labele budu poravnate u desnu stranu, postavljamo u ColumnConstraints sljedeće: halignment="RIGHT".
- nikad ne koristiti AnchorPane, loš dizajn jer nije resizable najčešće time nisu i responsive

## Stiliziranje pomoću CSSa

- ako želimo dodati CSS file, stavljamo u root pane fxml filea <stylesheets> tag i <URL> tag ali 
importujemo java.net.URL biblioteku, a NE javafx.print.URL
- klase u CSSu se označavaju tačkom, a ne sa #
- drugi način za dodavanje CSS filea je: scene.getStylesheets().add(getClass().getResorce("prijava.css").toExternalForm());

## Organizacija koda za resurse

- najbolje držati fxml, slike, css u resources folderu, a ne sa source code

## Praćenje izmjena kontrola

- initialize metoda - izvršava se nakon kreiranja prozora a prije ostalih metoda, jer će sva polja 
u controlleru biti inicijalizirana, ima oznaku @FXML
- listener (slušač) - funkcija koja će se izvršiti svaki put kada se desi određena promjena sa poljem,
tj. mogu biti i lambda funkcije koje će biti pozvane kada se neki property izmjeni

- Properties binding je mehanizam koji omogućava automatsko ažuriranje vrijednosti jedne promjenjive 
kada se promijeni vrijednost druge promijenjive, povezane sa prvom  (unidirectional binding), moze 
samo read da radi.
Npr. imamo app za rezervacije tiketa i sad korisnik rezervise neki tiket popunjavajuci polja, 
a sa drugim buttonom moze vidjeti svoj racun naravno sa tim podacima sto je tamo unio

- bidirectional binding je vrsta properties bindinga u kojoj se promjene od promjenjivih mogu reflektirati
u oba smjera, moze read i write npr. konverzija novca, dva polja za unos KM i eura, klikom na konverziju mijenja se vrijednost
od cijene s drugom valutom, KM->EUR, ali i EUR->KM